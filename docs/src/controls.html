<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Euro-Truck-Simulator-2-Lane-Assist.src.controls API documentation</title>
<meta name="description" content="Input manager for other plugins. This plugin will handle all the inputs and provide a way for other plugins to use them â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/ir-black.min.css" crossorigin>
<style>
:root {
--highlight-color: #202;
}
html {
scrollbar-face-color: #646464;
scrollbar-base-color: #646464;
scrollbar-3dlight-color: #646464;
scrollbar-highlight-color: #646464;
scrollbar-track-color: #000;
scrollbar-arrow-color: #000;
scrollbar-shadow-color: #646464;
scrollbar-dark-shadow-color: #646464;
}
::-webkit-scrollbar { width: 14px; height: 3px;}
::-webkit-scrollbar-button {
background-color: #000;
height: 3px;}
::-webkit-scrollbar-track {
background-color: #646464;}
::-webkit-scrollbar-track-piece { background-color: #000;}
::-webkit-scrollbar-thumb { height: 50px; background-color: #666; border-radius: 7px;}
::-webkit-scrollbar-corner { background-color: #646464;}
::-webkit-resizer { background-color: #666;}
.flex {
display: flex !important;
}
body {
line-height: 1.5em;
color: #fff;
background-color: #1e1e1e;
font: 14px/1.5 Helvetica, Arial, sans-serif;
margin: 0;
padding: 0;
}
#content {
padding: 20px;
}
#sidebar {
padding: 30px;
overflow: hidden;
}
#sidebar>*:last-child {
margin-bottom: 2cm;
}
.http-server-breadcrumbs {
font-size: 130%;
margin: 0 0 15px 0;
}
#footer {
font-size: .75em;
padding: 5px 30px;
border-top: 1px solid #fff;
text-align: right;
}
#footer p {
margin: 0 0 0 1em;
display: inline-block;
}
#footer p:last-child {
margin-right: 30px;
}
h1,
h2,
h3,
h4,
h5 {
font-weight: 300;
color: #fff;
}
h1 {
font-size: 2.5em;
line-height: 1.1em;
}
h2 {
font-size: 1.75em;
margin: 1em 0 .50em 0;
}
h3 {
font-size: 1.4em;
margin: 25px 0 10px 0;
}
h4 {
margin: 0;
font-size: 105%;
}
h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
background: #1e1e1e;
padding: 0.2em 0;
}
a {
color: #8fd6fc;
text-decoration: none;
transition: color .3s ease-in-out;
}
a:hover {
color: #00a4fc;
}
.title code {
font-weight: bold;
}
h2[id^="header-"] {
margin-top: 2em;
}
.ident {
color: #f6fc85;
}
strong {
color: #8fd6fc;
}
pre code {
background: transparent;
font-size: .8em;
line-height: 1.4em;
}
code {
background: rgba(255, 255, 255, 0.1);
padding: 1px 4px;
overflow-wrap: break-word;
}
h1 code {
background: transparent
}
pre {
background: transparent;
border: 0;
border-top: 1px solid #ccc;
border-bottom: 1px solid #ccc;
margin: 1em 0;
padding: 1ex;
}
#http-server-module-list {
display: flex;
flex-flow: column;
}
#http-server-module-list div {
display: flex;
}
#http-server-module-list dt {
min-width: 10%;
}
#http-server-module-list p {
margin-top: 0;
}
.toc ul,
#index {
list-style-type: none;
margin: 0;
padding: 0;
}
#index code {
background: transparent;
}
#index h3 {
border-bottom: 1px solid #ddd;
}
#index ul {
padding: 0;
}
#index h4 {
margin-top: .6em;
font-weight: bold;
}
/* Make TOC lists have 2+ columns when viewport is wide enough.
Assuming ~20-character identifiers and ~30% wide sidebar. */
@media (min-width: 200ex) {
#index .two-column {
column-count: 2
}
}
@media (min-width: 300ex) {
#index .two-column {
column-count: 3
}
}
dl {
margin-bottom: 2em;
}
dl dl:last-child {
margin-bottom: 4em;
}
dd {
margin: 0 0 1em 3em;
}
#header-classes+dl>dd {
margin-bottom: 3em;
}
dd dd {
margin-left: 2em;
}
dd p {
margin: 10px 0;
}
.name {
background: #000;
font-weight: bold;
font-size: .85em;
padding: 5px 10px;
display: inline-block;
min-width: 40%;
}
.name:hover {
background: #0b0b0b;
}
dt:target .name {
background: var(--highlight-color);
}
.name>span:first-child {
white-space: nowrap;
}
.name.class>span:nth-child(2) {
margin-left: .4em;
}
.inherited {
color: #999;
border-left: 5px solid #eee;
padding-left: 1em;
}
.inheritance em {
font-style: normal;
font-weight: bold;
}
.pydefname {
color: #f90;
}
/* Docstrings titles, e.g. in numpydoc format */
.desc h2 {
font-weight: 400;
font-size: 1.25em;
}
.desc h3 {
font-size: 1em;
}
.desc dt code {
background: inherit;
/* Don't grey-back parameters */
}
.source summary,
.git-link-div {
color: #666;
text-align: right;
font-weight: 400;
font-size: .8em;
text-transform: uppercase;
}
.source summary>* {
white-space: nowrap;
cursor: pointer;
}
.git-link {
color: inherit;
margin-left: 1em;
}
.source pre {
max-height: 500px;
overflow: auto;
margin: 0;
}
.source pre code {
font-size: 12px;
overflow: visible;
}
.hlist {
list-style: none;
}
.hlist li {
display: inline;
}
.hlist li:after {
content: ',\2002';
}
.hlist li:last-child:after {
content: none;
}
.hlist .hlist {
display: inline;
padding-left: 1em;
}
img {
max-width: 100%;
}
td {
padding: 0 .5em;
}
.admonition {
padding: .1em .5em;
margin-bottom: 1em;
}
.admonition-title {
font-weight: bold;
}
.admonition.note,
.admonition.info,
.admonition.important {
background: #00a;
}
.admonition.todo,
.admonition.versionadded,
.admonition.tip,
.admonition.hint {
background: #050;
}
.admonition.warning,
.admonition.versionchanged,
.admonition.deprecated {
background: #ec0;
}
.admonition.error,
.admonition.danger,
.admonition.caution {
background: #c20010;
}
p {
color: #fff;
}
</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Euro-Truck-Simulator-2-Lane-Assist.src.controls</code></h1>
</header>
<section id="section-intro">
<p>Input manager for other plugins. This plugin will handle all the inputs and provide a way for other plugins to use them.</p>
<pre><code class="language-python"># Will register a keybind to the input manager. This is necessary to use the keybind.
RegisterKeybind(name, callback=None, description=&quot;&quot;) 

# Will get the value of a keybind.
GetKeybindValue(name)
</code></pre>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Input manager for other plugins. This plugin will handle all the inputs and provide a way for other plugins to use them.

```python
# Will register a keybind to the input manager. This is necessary to use the keybind.
RegisterKeybind(name, callback=None, description=&#34;&#34;) 

# Will get the value of a keybind.
GetKeybindValue(name)
```
&#34;&#34;&#34;
import tkinter as tk
from tkinter import ttk
import src.helpers as helpers
import src.mainUI as mainUI
import src.variables as variables
import src.settings as settings
import os
from plugins.plugin import PluginInformation
import math
import pygame
import keyboard
from tktooltip import ToolTip
from src.logger import print

PluginInfo = PluginInformation(
    name=&#34;controls&#34;, # This needs to match the folder name under plugins (this would mean plugins\Panel\main.py)
    description=&#34;Provides a way to manage inputs unified for all plugins.&#34;,
    version=&#34;0.1&#34;,
    author=&#34;Tumppi066&#34;,
    url=&#34;https://github.com/Tumppi066/Euro-Truck-Simulator-2-Lane-Assist&#34;,
    type=&#34;static&#34; # = Panel
)

KEYBOARD_GUID = 1
KEYBINDS = []
def RegisterKeybind(name:str, callback=None, notBoundInfo:str=&#34;&#34;, description:str=&#34;&#34;, axis:bool=False, defaultButtonIndex:int=-1, defaultAxisIndex:int=-1):
    &#34;&#34;&#34;Will register a keybind to the input manager. This is necessary to use the keybind.

    Args:
        name (str): Keybind name. This is used to identify the keybind.
        callback (_type_, optional): Callback when the keybind is pressed. Defaults to None.
        notBoundInfo (str, optional): Will be shown to the user when nothing is bound. Useful for notifying of optional keybinds. Defaults to &#34;&#34;.
        description (str, optional): Additional description to the keybind. Defaults to &#34;&#34;.
        axis (bool, optional): Should the keybind be an axis.
    &#34;&#34;&#34;
    
    keybind = GetKeybindFromName(name)
    if keybind == None: # This is the first time we&#39;ve seen the keybind
        SaveKeybind(name, description=description, 
                    deviceGUID=KEYBOARD_GUID if type(defaultButtonIndex) == type(&#34;n&#34;) else -1, 
                    buttonIndex=defaultButtonIndex, 
                    axisIndex=defaultAxisIndex, 
                    shouldBeAxis=axis,
                    notBoundInfo=notBoundInfo)
        
        KEYBINDS.append({&#34;name&#34;: name, 
                         &#34;callback&#34;: callback, 
                         &#34;description&#34;: description, 
                         &#34;deviceGUID&#34;: KEYBOARD_GUID if type(defaultButtonIndex) == type(&#34;n&#34;) else -1, 
                         &#34;buttonIndex&#34;: defaultButtonIndex, 
                         &#34;axisIndex&#34;: defaultAxisIndex,
                         &#34;shouldBeAxis&#34;: axis,
                         &#34;notBoundInfo&#34;: notBoundInfo})
    else: # We already have data for the keybind
        KEYBINDS.append({&#34;name&#34;: name, 
                         &#34;callback&#34;: callback, 
                         &#34;description&#34;: description if description != keybind[&#34;description&#34;] else keybind[&#34;description&#34;], 
                         &#34;deviceGUID&#34;: keybind[&#34;deviceGUID&#34;], 
                         &#34;buttonIndex&#34;: keybind[&#34;buttonIndex&#34;], 
                         &#34;axisIndex&#34;: keybind[&#34;axisIndex&#34;],
                         &#34;shouldBeAxis&#34;: axis,
                         &#34;notBoundInfo&#34;: notBoundInfo if notBoundInfo != keybind[&#34;notBoundInfo&#34;] else keybind[&#34;notBoundInfo&#34;]})
        
def GetKeybindFromName(name):
    &#34;&#34;&#34;Get a keybind from the settings file.

    Args:
        name (str): Keybind name.

    Returns:
        dict: Keybind data.
    &#34;&#34;&#34;
    keybind = settings.GetSettings(&#34;Input&#34;, name)
    return keybind

def SaveKeybind(name, description=&#34;&#34;, deviceGUID=-1, buttonIndex=-1, axisIndex=-1, shouldBeAxis=False, notBoundInfo=&#34;&#34;):
    &#34;&#34;&#34;Save a keybind to the settings file.

    Args:
        name (str): Keybind name to save.
        description (str, optional): Description to save. Defaults to &#34;&#34;.
        deviceGUID (str, optional): Device GUID. Defaults to -1.
        buttonIndex (int, optional): Button index. If -1 buttons will not be considered. Defaults to -1.
        axisIndex (int, optional): Axis index. If -1 axis will not be considered. Defaults to -1.
        notBoundInfo (str, optional): Info to show when the keybind is not bound. Defaults to &#34;&#34;.
    &#34;&#34;&#34;
    settings.CreateSettings(&#34;Input&#34;, name, {&#34;description&#34;: description, &#34;deviceGUID&#34;: deviceGUID, &#34;buttonIndex&#34;: buttonIndex, &#34;axisIndex&#34;: axisIndex, &#34;shouldBeAxis&#34;: shouldBeAxis, &#34;notBoundInfo&#34;: notBoundInfo})    

pygame.init()
pygame.joystick.init()
joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
def plugin(data):
    &#34;&#34;&#34;Handles calling back the keybinds. Should not be called directly.

    Args:
        data (dict): Data dictionary from main.py

    Returns:
        dict: Data dictionary to main.py
    &#34;&#34;&#34;
    pygame.event.pump()
    for keybind in KEYBINDS:
        if keybind[&#34;callback&#34;] != None:
            if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
                if keyboard.is_pressed(keybind[&#34;buttonIndex&#34;]):
                    keybind[&#34;callback&#34;]()
            else:
                for joystick in joysticks:
                    if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                        if keybind[&#34;buttonIndex&#34;] != -1:
                            if joystick.get_button(keybind[&#34;buttonIndex&#34;]):
                                keybind[&#34;callback&#34;]()
                        elif keybind[&#34;axisIndex&#34;] != -1:
                            if abs(joystick.get_axis(keybind[&#34;axisIndex&#34;])) &gt; 0.4:
                                keybind[&#34;callback&#34;]()
            pass
    
    return data

def ChangeKeybind(name:str, updateUI:bool=True, callback=None):
    &#34;&#34;&#34;Will run the keybind change window code.

    Args:
        name (str): Keybind to change (name).
        updateUI (bool): Whether the UI should be updated (should be False if the function is called from other files).
        callback (function): Callback to run after the keybind has been changed.
    &#34;&#34;&#34;
    global save
    global ignore
    global currentbinding
    
    print(&#34;Changing keybind &#34; + name)
    # Make a new window to get the keybind on
    window = tk.Toplevel()
    window.title(&#34;Change keybind&#34;)
    mainUIPos = mainUI.root.winfo_x(), mainUI.root.winfo_y()
    window.geometry(f&#34;300x200+{mainUIPos[0] + 100}+{mainUIPos[1] + 100}&#34;)
    window.resizable(False, False)
    window.grab_set()
    window.focus_set()
    keybindToChange = KEYBINDS[KEYBINDS.index(next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None))]
    if keybindToChange == None:
        print(&#34;Keybind not found&#34;)
        return
    
    
    
    # Slider for the axis
    if keybindToChange[&#34;shouldBeAxis&#34;]:
        axisSlider = tk.Scale(window, from_=-1, to=1, orient=&#34;horizontal&#34;, length=200, resolution=0.01)
        axisSlider.pack()
        # Make a label to show the current keybind
        label = ttk.Label(window, text=&#34;Listening for input...\n(expecting an axis)&#34;)
        label.pack()
    else:
        # Make a label to show the current keybind
        label = ttk.Label(window, text=&#34;Listening for input...\n(expecting a button)&#34;)
        label.pack()
    
    ttk.Label(window, text=&#34;   &#34;).pack()
    
    def IgnoreBind():
        global ignore
        ignore = True
        print(&#34;Ignoring next input&#34;)
    
    def SaveBind():
        global save
        save = True
        window.destroy()
    
    # Ignore button
    ignoreButton = ttk.Button(window, text=&#34;Ignore&#34;, command=lambda: IgnoreBind(), width=30)
    ignoreButton.pack()
    
    # Save button
    saveButton = ttk.Button(window, text=&#34;Save&#34;, command=lambda: SaveBind(), width=30)
    saveButton.pack(pady=10)
    
    # Get all devices from pygame
    pygame.init()
    pygame.joystick.init()
    pygame.event.pump()
    joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
    
    import time
    time.sleep(0.2)
    pygame.event.pump()
    
    # For all devices, save the default state
    defaultStates = []
    for joystick in joysticks:
        defaultStates.append({&#34;name&#34;: joystick.get_name(), &#34;buttons&#34;: [joystick.get_button(i) for i in range(joystick.get_numbuttons())], &#34;axes&#34;: [joystick.get_axis(i) for i in range(joystick.get_numaxes())]})
    
    save = False
    ignore = False
    currentbinding = None
    
    def KeyboardEvent(event):
        global currentbinding
        if not keybindToChange[&#34;shouldBeAxis&#34;]:
            if len(event.keysym) &gt; 2:
                return # Ignore special keys
            label.config(text=f&#34;Key: &#39;{event.keysym}&#39;&#34;)
            currentbinding = {&#34;deviceGUID&#34;: KEYBOARD_GUID, &#34;buttonIndex&#34;: event.keysym}
    
    window.bind(&#34;&lt;Key&gt;&#34;, KeyboardEvent)
    window.protocol(&#34;WM_DELETE_WINDOW&#34;, lambda: SaveBind())
    
    def GetDistanceFromDefault(currentVal, defaultVal):
        return abs(currentVal - defaultVal)
    
    ignoredAxis = []
    ignoredButtons = []
    
    foundAxis = False
    while not save:
        # Check if any of the states change
        pygame.event.pump()
        for i in range(len(joysticks)):
            joystick = joysticks[i]
            defaultState = defaultStates[i]
            if not keybindToChange[&#34;shouldBeAxis&#34;]:
                for j in range(joystick.get_numbuttons()):
                    if defaultState[&#34;buttons&#34;][j] != joystick.get_button(j):
                        if ignore:
                            ignoredButtons.append(j)
                            ignore = False
                            label.config(text=f&#34;Listening for input...\n(expecting a button)&#34;)
                            continue
                        if j in ignoredButtons:
                            continue
                        
                        label.config(text=f&#34;Button: {j}&#34;)
                        currentbinding = {&#34;deviceGUID&#34;: joystick.get_guid(), &#34;buttonIndex&#34;: j}

            if keybindToChange[&#34;shouldBeAxis&#34;]:    
                for j in range(joystick.get_numaxes()):
                    if GetDistanceFromDefault(joystick.get_axis(j), defaultState[&#34;axes&#34;][j]) &gt; 0.2:
                        if ignore:
                            print(&#34;Ignoring axis &#34; + str(j))    
                            ignoredAxis.append(j)
                            ignore = False
                            label.config(text=f&#34;Listening for input...\n(expecting an axis)&#34;)
                            axisSlider.set(0)
                            continue
                        if j in ignoredAxis:
                            print(&#34;Ignoring axis &#34; + str(j))
                            continue
                        
                        label.config(text=f&#34;Axis: {j}&#34;)
                        axisSlider.set(joystick.get_axis(j))
                        currentbinding = {&#34;deviceGUID&#34;: joystick.get_guid(), &#34;axisIndex&#34;: j}
                        foundAxis = True

        if not foundAxis and keybindToChange[&#34;shouldBeAxis&#34;]:
            axisSlider.set(0)

        mainUI.root.update()
        window.update()
        foundAxis = False
        
    if currentbinding != None:
        SaveKeybind(name, deviceGUID=currentbinding[&#34;deviceGUID&#34;], buttonIndex=currentbinding[&#34;buttonIndex&#34;] if &#34;buttonIndex&#34; in currentbinding else -1, axisIndex=currentbinding[&#34;axisIndex&#34;] if &#34;axisIndex&#34; in currentbinding else -1)
        KEYBINDS[KEYBINDS.index(next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None))] = {&#34;name&#34;: name, 
                                                                                                     &#34;callback&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;callback&#34;], 
                                                                                                     &#34;description&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;description&#34;], 
                                                                                                     &#34;deviceGUID&#34;: currentbinding[&#34;deviceGUID&#34;], 
                                                                                                     &#34;buttonIndex&#34;: currentbinding[&#34;buttonIndex&#34;] if &#34;buttonIndex&#34; in currentbinding else -1, 
                                                                                                     &#34;axisIndex&#34;: currentbinding[&#34;axisIndex&#34;] if &#34;axisIndex&#34; in currentbinding else -1,
                                                                                                     &#34;shouldBeAxis&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;shouldBeAxis&#34;],
                                                                                                     &#34;notBoundInfo&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;notBoundInfo&#34;]}

        print(f&#34;Saved keybind {name}&#34;)

    if updateUI:
        mainUI.closeTabName(&#34;controls&#34;)
        mainUI.switchSelectedPlugin(&#34;src.controls&#34;)
        
    if callback != None:
        callback()
        
def UnbindKeybind(name, updateUI=True):
    &#34;&#34;&#34;Remove the binding of a keybind.

    Args:
        name (str): Keybind to remove (name).
        updateUI (bool, optional): Should the UI be updated (should be False if the function is called from other files). Defaults to True.
    &#34;&#34;&#34;
    SaveKeybind(name, deviceGUID=-1, buttonIndex=-1, axisIndex=-1)
    KEYBINDS[KEYBINDS.index(next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None))] = {&#34;name&#34;: name, 
                                                                                                 &#34;callback&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;callback&#34;], 
                                                                                                 &#34;description&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;description&#34;], 
                                                                                                 &#34;deviceGUID&#34;: -1, 
                                                                                                 &#34;buttonIndex&#34;: -1, 
                                                                                                 &#34;axisIndex&#34;: -1,
                                                                                                 &#34;shouldBeAxis&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;shouldBeAxis&#34;],
                                                                                                 &#34;notBoundInfo&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;notBoundInfo&#34;]}
    if updateUI:
        mainUI.closeTabName(&#34;controls&#34;)
        mainUI.switchSelectedPlugin(&#34;src.controls&#34;)


def GetKeybindValue(name:str):
    &#34;&#34;&#34;Will get the value of a keybind.

    Args:
        name (str): The name of the keybind to fetch.

    Returns:
        float | bool | str: Depending on whether the keybind is a button, axis or key, the value will be either a float, bool or str.
    &#34;&#34;&#34;
    keybind = None
    for bind in KEYBINDS:
        if bind[&#34;name&#34;] == name:
            keybind = bind
            break
        
    if keybind == None:
        return False
    
    if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
        try:
            return True if keyboard.is_pressed(keybind[&#34;buttonIndex&#34;]) else False
        except:
            return False
    
    if keybind[&#34;buttonIndex&#34;] == -1 and keybind[&#34;axisIndex&#34;] == -1:
        return False
    
    pygame.event.pump()
    joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
    try:
        for joystick in joysticks:
            if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                if keybind[&#34;buttonIndex&#34;] != -1:
                    return True if joystick.get_button(keybind[&#34;buttonIndex&#34;]) == 1 else False
                elif keybind[&#34;axisIndex&#34;] != -1:
                    return joystick.get_axis(keybind[&#34;axisIndex&#34;])
    except:
        return False
    
    return False

class UI():
    try: # The panel is in a try loop so that the logger can log errors if they occur
        
        def __init__(self, master) -&gt; None:
            self.master = master # &#34;master&#34; is the mainUI window
            # Check if the KEYBINDS list is empty. If so, then don&#39;t load the UI
            self.loadUI()
        
        def destroy(self):
            self.done = True
            self.root.destroy()
            del self

        
        def loadUI(self):
            
            try:
                self.root.destroy() # Load the UI each time this plugin is called
            except: pass
            
            self.root = tk.Canvas(self.master, width=700, height=600, border=0, highlightthickness=0)
            self.root.grid_propagate(0) # Don&#39;t fit the canvast to the widgets
            self.root.pack_propagate(0)
            
            self.controlsNotebook = ttk.Notebook(self.root, width=700, height=600)
            
            keybindCount = len(KEYBINDS)
            pages = []
            for i in range(math.ceil(keybindCount/6)):
                pages.append(ttk.Frame(self.controlsNotebook))
                self.controlsNotebook.add(pages[i], text=&#34;Page &#34; + str(i+1))
                self.controlsNotebook.pack(anchor=&#34;center&#34;, expand=False)
                
            i = 0
            page = 0
            
            pygame.init()
            pygame.joystick.init()
            joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
            
            for i in range(keybindCount):
                keybind = KEYBINDS[i]
                frame = ttk.LabelFrame(pages[page], text=&#34;Keybind  -  &#34; + keybind[&#34;name&#34;], width=700)
                
                # Make labels for the keybind information
                if keybind[&#34;deviceGUID&#34;] != -1:
                    noDevice = True
                    
                    if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
                        label = helpers.MakeLabel(frame, &#34;Device: Keyboard&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                        ToolTip(label, msg=&#34;GUID: &#34; + str(KEYBOARD_GUID) + &#34;\nThis is the keyboard connected to the computer.&#34;)
                        noDevice = False
                        
                    for joystick in joysticks:
                        if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                            label = helpers.MakeLabel(frame, &#34;Device: &#34; + joystick.get_name(), 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], tooltip=f&#34;GUID: {str(joystick.get_guid())}&#34;)
                            ToolTip(label, msg=f&#34;GUID: {str(joystick.get_guid())}&#34;)
                            noDevice = False
                            break
                        
                    if noDevice:
                        label = helpers.MakeLabel(frame, &#34;Device: Missing&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], fg=&#34;yellow&#34;)
                        ToolTip(label, msg=&#34;The device that was used to bind this keybind is not connected to the computer.\nGUID: &#34; + str(keybind[&#34;deviceGUID&#34;]))
                        
                if keybind[&#34;buttonIndex&#34;] != -1:
                    if type(keybind[&#34;buttonIndex&#34;]) == type(&#34;&#34;):
                        helpers.MakeLabel(frame, &#34;Key: &#34; + keybind[&#34;buttonIndex&#34;], 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                    else:
                        helpers.MakeLabel(frame, &#34;Button index: &#34; + str(keybind[&#34;buttonIndex&#34;]), 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                elif keybind[&#34;axisIndex&#34;] != -1:
                    helpers.MakeLabel(frame, &#34;Axis index: &#34; + str(keybind[&#34;axisIndex&#34;]), 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                
                if keybind[&#34;deviceGUID&#34;] == -1:
                    helpers.MakeLabel(frame, &#34;Not bound&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], fg=&#34;red&#34;)
                    if keybind[&#34;notBoundInfo&#34;] != &#34;&#34;:
                        helpers.MakeLabel(frame, keybind[&#34;notBoundInfo&#34;], 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                
                button = helpers.MakeButton(frame, &#34;Change&#34; if not keybind[&#34;deviceGUID&#34;] == -1 else &#34;Bind&#34;, lambda i=i: ChangeKeybind(KEYBINDS[i][&#34;name&#34;]), 0, 0, sticky=&#34;e&#34;, rowspan=3)
                
                if keybind[&#34;description&#34;] != &#34;&#34;:
                    ToolTip(button, msg=keybind[&#34;description&#34;])
                
                helpers.MakeButton(frame, &#34;Remove&#34;, lambda i=i: UnbindKeybind(KEYBINDS[i][&#34;name&#34;]), 0, 1, sticky=&#34;e&#34;, rowspan=3, state=&#34;disabled&#34; if keybind[&#34;deviceGUID&#34;] == -1 else &#34;!disabled&#34;)
                
                frame.pack(anchor=&#34;w&#34;, fill=&#34;x&#34;, expand=False)
                i += 1
                if i % 6 == 0:
                    page += 1
                    i = 0
            
            for i in range(len(pages)):
                self.controlsNotebook.tab(i, text=&#34;Page &#34; + str(i+1))
                
            
            
            self.controlsNotebook.pack(anchor=&#34;center&#34;, expand=False)
            self.root.pack(anchor=&#34;center&#34;, expand=False)
            self.root.update()
        
        
        def update(self, data): # When the panel is open this function is called each frame 
            self.root.update()
    
    
    except Exception as ex:
        print(ex.args)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.ChangeKeybind"><code class="name flex">
<span>def <span class="ident">ChangeKeybind</span></span>(<span>name:Â str, updateUI:Â boolÂ =Â True, callback=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Will run the keybind change window code.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Keybind to change (name).</dd>
<dt><strong><code>updateUI</code></strong> :&ensp;<code>bool</code></dt>
<dd>Whether the UI should be updated (should be False if the function is called from other files).</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>function</code></dt>
<dd>Callback to run after the keybind has been changed.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ChangeKeybind(name:str, updateUI:bool=True, callback=None):
    &#34;&#34;&#34;Will run the keybind change window code.

    Args:
        name (str): Keybind to change (name).
        updateUI (bool): Whether the UI should be updated (should be False if the function is called from other files).
        callback (function): Callback to run after the keybind has been changed.
    &#34;&#34;&#34;
    global save
    global ignore
    global currentbinding
    
    print(&#34;Changing keybind &#34; + name)
    # Make a new window to get the keybind on
    window = tk.Toplevel()
    window.title(&#34;Change keybind&#34;)
    mainUIPos = mainUI.root.winfo_x(), mainUI.root.winfo_y()
    window.geometry(f&#34;300x200+{mainUIPos[0] + 100}+{mainUIPos[1] + 100}&#34;)
    window.resizable(False, False)
    window.grab_set()
    window.focus_set()
    keybindToChange = KEYBINDS[KEYBINDS.index(next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None))]
    if keybindToChange == None:
        print(&#34;Keybind not found&#34;)
        return
    
    
    
    # Slider for the axis
    if keybindToChange[&#34;shouldBeAxis&#34;]:
        axisSlider = tk.Scale(window, from_=-1, to=1, orient=&#34;horizontal&#34;, length=200, resolution=0.01)
        axisSlider.pack()
        # Make a label to show the current keybind
        label = ttk.Label(window, text=&#34;Listening for input...\n(expecting an axis)&#34;)
        label.pack()
    else:
        # Make a label to show the current keybind
        label = ttk.Label(window, text=&#34;Listening for input...\n(expecting a button)&#34;)
        label.pack()
    
    ttk.Label(window, text=&#34;   &#34;).pack()
    
    def IgnoreBind():
        global ignore
        ignore = True
        print(&#34;Ignoring next input&#34;)
    
    def SaveBind():
        global save
        save = True
        window.destroy()
    
    # Ignore button
    ignoreButton = ttk.Button(window, text=&#34;Ignore&#34;, command=lambda: IgnoreBind(), width=30)
    ignoreButton.pack()
    
    # Save button
    saveButton = ttk.Button(window, text=&#34;Save&#34;, command=lambda: SaveBind(), width=30)
    saveButton.pack(pady=10)
    
    # Get all devices from pygame
    pygame.init()
    pygame.joystick.init()
    pygame.event.pump()
    joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
    
    import time
    time.sleep(0.2)
    pygame.event.pump()
    
    # For all devices, save the default state
    defaultStates = []
    for joystick in joysticks:
        defaultStates.append({&#34;name&#34;: joystick.get_name(), &#34;buttons&#34;: [joystick.get_button(i) for i in range(joystick.get_numbuttons())], &#34;axes&#34;: [joystick.get_axis(i) for i in range(joystick.get_numaxes())]})
    
    save = False
    ignore = False
    currentbinding = None
    
    def KeyboardEvent(event):
        global currentbinding
        if not keybindToChange[&#34;shouldBeAxis&#34;]:
            if len(event.keysym) &gt; 2:
                return # Ignore special keys
            label.config(text=f&#34;Key: &#39;{event.keysym}&#39;&#34;)
            currentbinding = {&#34;deviceGUID&#34;: KEYBOARD_GUID, &#34;buttonIndex&#34;: event.keysym}
    
    window.bind(&#34;&lt;Key&gt;&#34;, KeyboardEvent)
    window.protocol(&#34;WM_DELETE_WINDOW&#34;, lambda: SaveBind())
    
    def GetDistanceFromDefault(currentVal, defaultVal):
        return abs(currentVal - defaultVal)
    
    ignoredAxis = []
    ignoredButtons = []
    
    foundAxis = False
    while not save:
        # Check if any of the states change
        pygame.event.pump()
        for i in range(len(joysticks)):
            joystick = joysticks[i]
            defaultState = defaultStates[i]
            if not keybindToChange[&#34;shouldBeAxis&#34;]:
                for j in range(joystick.get_numbuttons()):
                    if defaultState[&#34;buttons&#34;][j] != joystick.get_button(j):
                        if ignore:
                            ignoredButtons.append(j)
                            ignore = False
                            label.config(text=f&#34;Listening for input...\n(expecting a button)&#34;)
                            continue
                        if j in ignoredButtons:
                            continue
                        
                        label.config(text=f&#34;Button: {j}&#34;)
                        currentbinding = {&#34;deviceGUID&#34;: joystick.get_guid(), &#34;buttonIndex&#34;: j}

            if keybindToChange[&#34;shouldBeAxis&#34;]:    
                for j in range(joystick.get_numaxes()):
                    if GetDistanceFromDefault(joystick.get_axis(j), defaultState[&#34;axes&#34;][j]) &gt; 0.2:
                        if ignore:
                            print(&#34;Ignoring axis &#34; + str(j))    
                            ignoredAxis.append(j)
                            ignore = False
                            label.config(text=f&#34;Listening for input...\n(expecting an axis)&#34;)
                            axisSlider.set(0)
                            continue
                        if j in ignoredAxis:
                            print(&#34;Ignoring axis &#34; + str(j))
                            continue
                        
                        label.config(text=f&#34;Axis: {j}&#34;)
                        axisSlider.set(joystick.get_axis(j))
                        currentbinding = {&#34;deviceGUID&#34;: joystick.get_guid(), &#34;axisIndex&#34;: j}
                        foundAxis = True

        if not foundAxis and keybindToChange[&#34;shouldBeAxis&#34;]:
            axisSlider.set(0)

        mainUI.root.update()
        window.update()
        foundAxis = False
        
    if currentbinding != None:
        SaveKeybind(name, deviceGUID=currentbinding[&#34;deviceGUID&#34;], buttonIndex=currentbinding[&#34;buttonIndex&#34;] if &#34;buttonIndex&#34; in currentbinding else -1, axisIndex=currentbinding[&#34;axisIndex&#34;] if &#34;axisIndex&#34; in currentbinding else -1)
        KEYBINDS[KEYBINDS.index(next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None))] = {&#34;name&#34;: name, 
                                                                                                     &#34;callback&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;callback&#34;], 
                                                                                                     &#34;description&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;description&#34;], 
                                                                                                     &#34;deviceGUID&#34;: currentbinding[&#34;deviceGUID&#34;], 
                                                                                                     &#34;buttonIndex&#34;: currentbinding[&#34;buttonIndex&#34;] if &#34;buttonIndex&#34; in currentbinding else -1, 
                                                                                                     &#34;axisIndex&#34;: currentbinding[&#34;axisIndex&#34;] if &#34;axisIndex&#34; in currentbinding else -1,
                                                                                                     &#34;shouldBeAxis&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;shouldBeAxis&#34;],
                                                                                                     &#34;notBoundInfo&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;notBoundInfo&#34;]}

        print(f&#34;Saved keybind {name}&#34;)

    if updateUI:
        mainUI.closeTabName(&#34;controls&#34;)
        mainUI.switchSelectedPlugin(&#34;src.controls&#34;)
        
    if callback != None:
        callback()</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.GetKeybindFromName"><code class="name flex">
<span>def <span class="ident">GetKeybindFromName</span></span>(<span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Get a keybind from the settings file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Keybind name.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Keybind data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetKeybindFromName(name):
    &#34;&#34;&#34;Get a keybind from the settings file.

    Args:
        name (str): Keybind name.

    Returns:
        dict: Keybind data.
    &#34;&#34;&#34;
    keybind = settings.GetSettings(&#34;Input&#34;, name)
    return keybind</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.GetKeybindValue"><code class="name flex">
<span>def <span class="ident">GetKeybindValue</span></span>(<span>name:Â str)</span>
</code></dt>
<dd>
<div class="desc"><p>Will get the value of a keybind.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the keybind to fetch.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>float | bool | str: Depending on whether the keybind is a button, axis or key, the value will be either a float, bool or str.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def GetKeybindValue(name:str):
    &#34;&#34;&#34;Will get the value of a keybind.

    Args:
        name (str): The name of the keybind to fetch.

    Returns:
        float | bool | str: Depending on whether the keybind is a button, axis or key, the value will be either a float, bool or str.
    &#34;&#34;&#34;
    keybind = None
    for bind in KEYBINDS:
        if bind[&#34;name&#34;] == name:
            keybind = bind
            break
        
    if keybind == None:
        return False
    
    if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
        try:
            return True if keyboard.is_pressed(keybind[&#34;buttonIndex&#34;]) else False
        except:
            return False
    
    if keybind[&#34;buttonIndex&#34;] == -1 and keybind[&#34;axisIndex&#34;] == -1:
        return False
    
    pygame.event.pump()
    joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
    try:
        for joystick in joysticks:
            if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                if keybind[&#34;buttonIndex&#34;] != -1:
                    return True if joystick.get_button(keybind[&#34;buttonIndex&#34;]) == 1 else False
                elif keybind[&#34;axisIndex&#34;] != -1:
                    return joystick.get_axis(keybind[&#34;axisIndex&#34;])
    except:
        return False
    
    return False</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.RegisterKeybind"><code class="name flex">
<span>def <span class="ident">RegisterKeybind</span></span>(<span>name:Â str, callback=None, notBoundInfo:Â strÂ =Â '', description:Â strÂ =Â '', axis:Â boolÂ =Â False, defaultButtonIndex:Â intÂ =Â -1, defaultAxisIndex:Â intÂ =Â -1)</span>
</code></dt>
<dd>
<div class="desc"><p>Will register a keybind to the input manager. This is necessary to use the keybind.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Keybind name. This is used to identify the keybind.</dd>
<dt><strong><code>callback</code></strong> :&ensp;<code>_type_</code>, optional</dt>
<dd>Callback when the keybind is pressed. Defaults to None.</dd>
<dt><strong><code>notBoundInfo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Will be shown to the user when nothing is bound. Useful for notifying of optional keybinds. Defaults to "".</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Additional description to the keybind. Defaults to "".</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the keybind be an axis.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def RegisterKeybind(name:str, callback=None, notBoundInfo:str=&#34;&#34;, description:str=&#34;&#34;, axis:bool=False, defaultButtonIndex:int=-1, defaultAxisIndex:int=-1):
    &#34;&#34;&#34;Will register a keybind to the input manager. This is necessary to use the keybind.

    Args:
        name (str): Keybind name. This is used to identify the keybind.
        callback (_type_, optional): Callback when the keybind is pressed. Defaults to None.
        notBoundInfo (str, optional): Will be shown to the user when nothing is bound. Useful for notifying of optional keybinds. Defaults to &#34;&#34;.
        description (str, optional): Additional description to the keybind. Defaults to &#34;&#34;.
        axis (bool, optional): Should the keybind be an axis.
    &#34;&#34;&#34;
    
    keybind = GetKeybindFromName(name)
    if keybind == None: # This is the first time we&#39;ve seen the keybind
        SaveKeybind(name, description=description, 
                    deviceGUID=KEYBOARD_GUID if type(defaultButtonIndex) == type(&#34;n&#34;) else -1, 
                    buttonIndex=defaultButtonIndex, 
                    axisIndex=defaultAxisIndex, 
                    shouldBeAxis=axis,
                    notBoundInfo=notBoundInfo)
        
        KEYBINDS.append({&#34;name&#34;: name, 
                         &#34;callback&#34;: callback, 
                         &#34;description&#34;: description, 
                         &#34;deviceGUID&#34;: KEYBOARD_GUID if type(defaultButtonIndex) == type(&#34;n&#34;) else -1, 
                         &#34;buttonIndex&#34;: defaultButtonIndex, 
                         &#34;axisIndex&#34;: defaultAxisIndex,
                         &#34;shouldBeAxis&#34;: axis,
                         &#34;notBoundInfo&#34;: notBoundInfo})
    else: # We already have data for the keybind
        KEYBINDS.append({&#34;name&#34;: name, 
                         &#34;callback&#34;: callback, 
                         &#34;description&#34;: description if description != keybind[&#34;description&#34;] else keybind[&#34;description&#34;], 
                         &#34;deviceGUID&#34;: keybind[&#34;deviceGUID&#34;], 
                         &#34;buttonIndex&#34;: keybind[&#34;buttonIndex&#34;], 
                         &#34;axisIndex&#34;: keybind[&#34;axisIndex&#34;],
                         &#34;shouldBeAxis&#34;: axis,
                         &#34;notBoundInfo&#34;: notBoundInfo if notBoundInfo != keybind[&#34;notBoundInfo&#34;] else keybind[&#34;notBoundInfo&#34;]})</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.SaveKeybind"><code class="name flex">
<span>def <span class="ident">SaveKeybind</span></span>(<span>name, description='', deviceGUID=-1, buttonIndex=-1, axisIndex=-1, shouldBeAxis=False, notBoundInfo='')</span>
</code></dt>
<dd>
<div class="desc"><p>Save a keybind to the settings file.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Keybind name to save.</dd>
<dt><strong><code>description</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Description to save. Defaults to "".</dd>
<dt><strong><code>deviceGUID</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Device GUID. Defaults to -1.</dd>
<dt><strong><code>buttonIndex</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Button index. If -1 buttons will not be considered. Defaults to -1.</dd>
<dt><strong><code>axisIndex</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Axis index. If -1 axis will not be considered. Defaults to -1.</dd>
<dt><strong><code>notBoundInfo</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>Info to show when the keybind is not bound. Defaults to "".</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def SaveKeybind(name, description=&#34;&#34;, deviceGUID=-1, buttonIndex=-1, axisIndex=-1, shouldBeAxis=False, notBoundInfo=&#34;&#34;):
    &#34;&#34;&#34;Save a keybind to the settings file.

    Args:
        name (str): Keybind name to save.
        description (str, optional): Description to save. Defaults to &#34;&#34;.
        deviceGUID (str, optional): Device GUID. Defaults to -1.
        buttonIndex (int, optional): Button index. If -1 buttons will not be considered. Defaults to -1.
        axisIndex (int, optional): Axis index. If -1 axis will not be considered. Defaults to -1.
        notBoundInfo (str, optional): Info to show when the keybind is not bound. Defaults to &#34;&#34;.
    &#34;&#34;&#34;
    settings.CreateSettings(&#34;Input&#34;, name, {&#34;description&#34;: description, &#34;deviceGUID&#34;: deviceGUID, &#34;buttonIndex&#34;: buttonIndex, &#34;axisIndex&#34;: axisIndex, &#34;shouldBeAxis&#34;: shouldBeAxis, &#34;notBoundInfo&#34;: notBoundInfo})    </code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UnbindKeybind"><code class="name flex">
<span>def <span class="ident">UnbindKeybind</span></span>(<span>name, updateUI=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the binding of a keybind.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Keybind to remove (name).</dd>
<dt><strong><code>updateUI</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Should the UI be updated (should be False if the function is called from other files). Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def UnbindKeybind(name, updateUI=True):
    &#34;&#34;&#34;Remove the binding of a keybind.

    Args:
        name (str): Keybind to remove (name).
        updateUI (bool, optional): Should the UI be updated (should be False if the function is called from other files). Defaults to True.
    &#34;&#34;&#34;
    SaveKeybind(name, deviceGUID=-1, buttonIndex=-1, axisIndex=-1)
    KEYBINDS[KEYBINDS.index(next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None))] = {&#34;name&#34;: name, 
                                                                                                 &#34;callback&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;callback&#34;], 
                                                                                                 &#34;description&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;description&#34;], 
                                                                                                 &#34;deviceGUID&#34;: -1, 
                                                                                                 &#34;buttonIndex&#34;: -1, 
                                                                                                 &#34;axisIndex&#34;: -1,
                                                                                                 &#34;shouldBeAxis&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;shouldBeAxis&#34;],
                                                                                                 &#34;notBoundInfo&#34;: next((item for item in KEYBINDS if item[&#34;name&#34;] == name), None)[&#34;notBoundInfo&#34;]}
    if updateUI:
        mainUI.closeTabName(&#34;controls&#34;)
        mainUI.switchSelectedPlugin(&#34;src.controls&#34;)</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.plugin"><code class="name flex">
<span>def <span class="ident">plugin</span></span>(<span>data)</span>
</code></dt>
<dd>
<div class="desc"><p>Handles calling back the keybinds. Should not be called directly.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>dict</code></dt>
<dd>Data dictionary from main.py</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>dict</code></dt>
<dd>Data dictionary to main.py</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plugin(data):
    &#34;&#34;&#34;Handles calling back the keybinds. Should not be called directly.

    Args:
        data (dict): Data dictionary from main.py

    Returns:
        dict: Data dictionary to main.py
    &#34;&#34;&#34;
    pygame.event.pump()
    for keybind in KEYBINDS:
        if keybind[&#34;callback&#34;] != None:
            if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
                if keyboard.is_pressed(keybind[&#34;buttonIndex&#34;]):
                    keybind[&#34;callback&#34;]()
            else:
                for joystick in joysticks:
                    if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                        if keybind[&#34;buttonIndex&#34;] != -1:
                            if joystick.get_button(keybind[&#34;buttonIndex&#34;]):
                                keybind[&#34;callback&#34;]()
                        elif keybind[&#34;axisIndex&#34;] != -1:
                            if abs(joystick.get_axis(keybind[&#34;axisIndex&#34;])) &gt; 0.4:
                                keybind[&#34;callback&#34;]()
            pass
    
    return data</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI"><code class="flex name class">
<span>class <span class="ident">UI</span></span>
<span>(</span><span>master)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UI():
    try: # The panel is in a try loop so that the logger can log errors if they occur
        
        def __init__(self, master) -&gt; None:
            self.master = master # &#34;master&#34; is the mainUI window
            # Check if the KEYBINDS list is empty. If so, then don&#39;t load the UI
            self.loadUI()
        
        def destroy(self):
            self.done = True
            self.root.destroy()
            del self

        
        def loadUI(self):
            
            try:
                self.root.destroy() # Load the UI each time this plugin is called
            except: pass
            
            self.root = tk.Canvas(self.master, width=700, height=600, border=0, highlightthickness=0)
            self.root.grid_propagate(0) # Don&#39;t fit the canvast to the widgets
            self.root.pack_propagate(0)
            
            self.controlsNotebook = ttk.Notebook(self.root, width=700, height=600)
            
            keybindCount = len(KEYBINDS)
            pages = []
            for i in range(math.ceil(keybindCount/6)):
                pages.append(ttk.Frame(self.controlsNotebook))
                self.controlsNotebook.add(pages[i], text=&#34;Page &#34; + str(i+1))
                self.controlsNotebook.pack(anchor=&#34;center&#34;, expand=False)
                
            i = 0
            page = 0
            
            pygame.init()
            pygame.joystick.init()
            joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
            
            for i in range(keybindCount):
                keybind = KEYBINDS[i]
                frame = ttk.LabelFrame(pages[page], text=&#34;Keybind  -  &#34; + keybind[&#34;name&#34;], width=700)
                
                # Make labels for the keybind information
                if keybind[&#34;deviceGUID&#34;] != -1:
                    noDevice = True
                    
                    if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
                        label = helpers.MakeLabel(frame, &#34;Device: Keyboard&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                        ToolTip(label, msg=&#34;GUID: &#34; + str(KEYBOARD_GUID) + &#34;\nThis is the keyboard connected to the computer.&#34;)
                        noDevice = False
                        
                    for joystick in joysticks:
                        if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                            label = helpers.MakeLabel(frame, &#34;Device: &#34; + joystick.get_name(), 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], tooltip=f&#34;GUID: {str(joystick.get_guid())}&#34;)
                            ToolTip(label, msg=f&#34;GUID: {str(joystick.get_guid())}&#34;)
                            noDevice = False
                            break
                        
                    if noDevice:
                        label = helpers.MakeLabel(frame, &#34;Device: Missing&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], fg=&#34;yellow&#34;)
                        ToolTip(label, msg=&#34;The device that was used to bind this keybind is not connected to the computer.\nGUID: &#34; + str(keybind[&#34;deviceGUID&#34;]))
                        
                if keybind[&#34;buttonIndex&#34;] != -1:
                    if type(keybind[&#34;buttonIndex&#34;]) == type(&#34;&#34;):
                        helpers.MakeLabel(frame, &#34;Key: &#34; + keybind[&#34;buttonIndex&#34;], 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                    else:
                        helpers.MakeLabel(frame, &#34;Button index: &#34; + str(keybind[&#34;buttonIndex&#34;]), 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                elif keybind[&#34;axisIndex&#34;] != -1:
                    helpers.MakeLabel(frame, &#34;Axis index: &#34; + str(keybind[&#34;axisIndex&#34;]), 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                
                if keybind[&#34;deviceGUID&#34;] == -1:
                    helpers.MakeLabel(frame, &#34;Not bound&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], fg=&#34;red&#34;)
                    if keybind[&#34;notBoundInfo&#34;] != &#34;&#34;:
                        helpers.MakeLabel(frame, keybind[&#34;notBoundInfo&#34;], 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                
                button = helpers.MakeButton(frame, &#34;Change&#34; if not keybind[&#34;deviceGUID&#34;] == -1 else &#34;Bind&#34;, lambda i=i: ChangeKeybind(KEYBINDS[i][&#34;name&#34;]), 0, 0, sticky=&#34;e&#34;, rowspan=3)
                
                if keybind[&#34;description&#34;] != &#34;&#34;:
                    ToolTip(button, msg=keybind[&#34;description&#34;])
                
                helpers.MakeButton(frame, &#34;Remove&#34;, lambda i=i: UnbindKeybind(KEYBINDS[i][&#34;name&#34;]), 0, 1, sticky=&#34;e&#34;, rowspan=3, state=&#34;disabled&#34; if keybind[&#34;deviceGUID&#34;] == -1 else &#34;!disabled&#34;)
                
                frame.pack(anchor=&#34;w&#34;, fill=&#34;x&#34;, expand=False)
                i += 1
                if i % 6 == 0:
                    page += 1
                    i = 0
            
            for i in range(len(pages)):
                self.controlsNotebook.tab(i, text=&#34;Page &#34; + str(i+1))
                
            
            
            self.controlsNotebook.pack(anchor=&#34;center&#34;, expand=False)
            self.root.pack(anchor=&#34;center&#34;, expand=False)
            self.root.update()
        
        
        def update(self, data): # When the panel is open this function is called each frame 
            self.root.update()
    
    
    except Exception as ex:
        print(ex.args)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.destroy"><code class="name flex">
<span>def <span class="ident">destroy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy(self):
    self.done = True
    self.root.destroy()
    del self</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.loadUI"><code class="name flex">
<span>def <span class="ident">loadUI</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadUI(self):
    
    try:
        self.root.destroy() # Load the UI each time this plugin is called
    except: pass
    
    self.root = tk.Canvas(self.master, width=700, height=600, border=0, highlightthickness=0)
    self.root.grid_propagate(0) # Don&#39;t fit the canvast to the widgets
    self.root.pack_propagate(0)
    
    self.controlsNotebook = ttk.Notebook(self.root, width=700, height=600)
    
    keybindCount = len(KEYBINDS)
    pages = []
    for i in range(math.ceil(keybindCount/6)):
        pages.append(ttk.Frame(self.controlsNotebook))
        self.controlsNotebook.add(pages[i], text=&#34;Page &#34; + str(i+1))
        self.controlsNotebook.pack(anchor=&#34;center&#34;, expand=False)
        
    i = 0
    page = 0
    
    pygame.init()
    pygame.joystick.init()
    joysticks = [pygame.joystick.Joystick(i) for i in range(pygame.joystick.get_count())]
    
    for i in range(keybindCount):
        keybind = KEYBINDS[i]
        frame = ttk.LabelFrame(pages[page], text=&#34;Keybind  -  &#34; + keybind[&#34;name&#34;], width=700)
        
        # Make labels for the keybind information
        if keybind[&#34;deviceGUID&#34;] != -1:
            noDevice = True
            
            if keybind[&#34;deviceGUID&#34;] == KEYBOARD_GUID:
                label = helpers.MakeLabel(frame, &#34;Device: Keyboard&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
                ToolTip(label, msg=&#34;GUID: &#34; + str(KEYBOARD_GUID) + &#34;\nThis is the keyboard connected to the computer.&#34;)
                noDevice = False
                
            for joystick in joysticks:
                if joystick.get_guid() == keybind[&#34;deviceGUID&#34;]:
                    label = helpers.MakeLabel(frame, &#34;Device: &#34; + joystick.get_name(), 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], tooltip=f&#34;GUID: {str(joystick.get_guid())}&#34;)
                    ToolTip(label, msg=f&#34;GUID: {str(joystick.get_guid())}&#34;)
                    noDevice = False
                    break
                
            if noDevice:
                label = helpers.MakeLabel(frame, &#34;Device: Missing&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], fg=&#34;yellow&#34;)
                ToolTip(label, msg=&#34;The device that was used to bind this keybind is not connected to the computer.\nGUID: &#34; + str(keybind[&#34;deviceGUID&#34;]))
                
        if keybind[&#34;buttonIndex&#34;] != -1:
            if type(keybind[&#34;buttonIndex&#34;]) == type(&#34;&#34;):
                helpers.MakeLabel(frame, &#34;Key: &#34; + keybind[&#34;buttonIndex&#34;], 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
            else:
                helpers.MakeLabel(frame, &#34;Button index: &#34; + str(keybind[&#34;buttonIndex&#34;]), 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
        elif keybind[&#34;axisIndex&#34;] != -1:
            helpers.MakeLabel(frame, &#34;Axis index: &#34; + str(keybind[&#34;axisIndex&#34;]), 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
        
        if keybind[&#34;deviceGUID&#34;] == -1:
            helpers.MakeLabel(frame, &#34;Not bound&#34;, 0, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;], fg=&#34;red&#34;)
            if keybind[&#34;notBoundInfo&#34;] != &#34;&#34;:
                helpers.MakeLabel(frame, keybind[&#34;notBoundInfo&#34;], 1, 2, sticky=&#34;w&#34;, padx=10, pady=0, font=[&#34;Segoe UI&#34;, 10, &#34;bold&#34;])
        
        button = helpers.MakeButton(frame, &#34;Change&#34; if not keybind[&#34;deviceGUID&#34;] == -1 else &#34;Bind&#34;, lambda i=i: ChangeKeybind(KEYBINDS[i][&#34;name&#34;]), 0, 0, sticky=&#34;e&#34;, rowspan=3)
        
        if keybind[&#34;description&#34;] != &#34;&#34;:
            ToolTip(button, msg=keybind[&#34;description&#34;])
        
        helpers.MakeButton(frame, &#34;Remove&#34;, lambda i=i: UnbindKeybind(KEYBINDS[i][&#34;name&#34;]), 0, 1, sticky=&#34;e&#34;, rowspan=3, state=&#34;disabled&#34; if keybind[&#34;deviceGUID&#34;] == -1 else &#34;!disabled&#34;)
        
        frame.pack(anchor=&#34;w&#34;, fill=&#34;x&#34;, expand=False)
        i += 1
        if i % 6 == 0:
            page += 1
            i = 0
    
    for i in range(len(pages)):
        self.controlsNotebook.tab(i, text=&#34;Page &#34; + str(i+1))
        
    
    
    self.controlsNotebook.pack(anchor=&#34;center&#34;, expand=False)
    self.root.pack(anchor=&#34;center&#34;, expand=False)
    self.root.update()</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, data)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, data): # When the panel is open this function is called each frame 
    self.root.update()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src" href="index.html">Euro-Truck-Simulator-2-Lane-Assist.src</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.ChangeKeybind" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.ChangeKeybind">ChangeKeybind</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.GetKeybindFromName" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.GetKeybindFromName">GetKeybindFromName</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.GetKeybindValue" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.GetKeybindValue">GetKeybindValue</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.RegisterKeybind" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.RegisterKeybind">RegisterKeybind</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.SaveKeybind" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.SaveKeybind">SaveKeybind</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UnbindKeybind" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.UnbindKeybind">UnbindKeybind</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.plugin" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.plugin">plugin</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI">UI</a></code></h4>
<ul class="">
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.destroy" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.destroy">destroy</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.loadUI" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.loadUI">loadUI</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.update" href="#Euro-Truck-Simulator-2-Lane-Assist.src.controls.UI.update">update</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>