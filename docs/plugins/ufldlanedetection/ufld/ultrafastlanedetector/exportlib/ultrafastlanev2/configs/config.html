<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/ir-black.min.css" crossorigin>
<style>
:root {
--highlight-color: #202;
}
html {
scrollbar-face-color: #646464;
scrollbar-base-color: #646464;
scrollbar-3dlight-color: #646464;
scrollbar-highlight-color: #646464;
scrollbar-track-color: #000;
scrollbar-arrow-color: #000;
scrollbar-shadow-color: #646464;
scrollbar-dark-shadow-color: #646464;
}
::-webkit-scrollbar { width: 14px; height: 3px;}
::-webkit-scrollbar-button {
background-color: #000;
height: 3px;}
::-webkit-scrollbar-track {
background-color: #646464;}
::-webkit-scrollbar-track-piece { background-color: #000;}
::-webkit-scrollbar-thumb { height: 50px; background-color: #666; border-radius: 7px;}
::-webkit-scrollbar-corner { background-color: #646464;}
::-webkit-resizer { background-color: #666;}
.flex {
display: flex !important;
}
body {
line-height: 1.5em;
color: #fff;
background-color: #1e1e1e;
font: 14px/1.5 Helvetica, Arial, sans-serif;
margin: 0;
padding: 0;
}
#content {
padding: 20px;
}
#sidebar {
padding: 30px;
overflow: hidden;
}
#sidebar>*:last-child {
margin-bottom: 2cm;
}
.http-server-breadcrumbs {
font-size: 130%;
margin: 0 0 15px 0;
}
#footer {
font-size: .75em;
padding: 5px 30px;
border-top: 1px solid #fff;
text-align: right;
}
#footer p {
margin: 0 0 0 1em;
display: inline-block;
}
#footer p:last-child {
margin-right: 30px;
}
h1,
h2,
h3,
h4,
h5 {
font-weight: 300;
color: #fff;
}
h1 {
font-size: 2.5em;
line-height: 1.1em;
}
h2 {
font-size: 1.75em;
margin: 1em 0 .50em 0;
}
h3 {
font-size: 1.4em;
margin: 25px 0 10px 0;
}
h4 {
margin: 0;
font-size: 105%;
}
h1:target,
h2:target,
h3:target,
h4:target,
h5:target,
h6:target {
background: #1e1e1e;
padding: 0.2em 0;
}
a {
color: #8fd6fc;
text-decoration: none;
transition: color .3s ease-in-out;
}
a:hover {
color: #00a4fc;
}
.title code {
font-weight: bold;
}
h2[id^="header-"] {
margin-top: 2em;
}
.ident {
color: #f6fc85;
}
strong {
color: #8fd6fc;
}
pre code {
background: transparent;
font-size: .8em;
line-height: 1.4em;
}
code {
background: rgba(255, 255, 255, 0.1);
padding: 1px 4px;
overflow-wrap: break-word;
}
h1 code {
background: transparent
}
pre {
background: transparent;
border: 0;
border-top: 1px solid #ccc;
border-bottom: 1px solid #ccc;
margin: 1em 0;
padding: 1ex;
}
#http-server-module-list {
display: flex;
flex-flow: column;
}
#http-server-module-list div {
display: flex;
}
#http-server-module-list dt {
min-width: 10%;
}
#http-server-module-list p {
margin-top: 0;
}
.toc ul,
#index {
list-style-type: none;
margin: 0;
padding: 0;
}
#index code {
background: transparent;
}
#index h3 {
border-bottom: 1px solid #ddd;
}
#index ul {
padding: 0;
}
#index h4 {
margin-top: .6em;
font-weight: bold;
}
/* Make TOC lists have 2+ columns when viewport is wide enough.
Assuming ~20-character identifiers and ~30% wide sidebar. */
@media (min-width: 200ex) {
#index .two-column {
column-count: 2
}
}
@media (min-width: 300ex) {
#index .two-column {
column-count: 3
}
}
dl {
margin-bottom: 2em;
}
dl dl:last-child {
margin-bottom: 4em;
}
dd {
margin: 0 0 1em 3em;
}
#header-classes+dl>dd {
margin-bottom: 3em;
}
dd dd {
margin-left: 2em;
}
dd p {
margin: 10px 0;
}
.name {
background: #000;
font-weight: bold;
font-size: .85em;
padding: 5px 10px;
display: inline-block;
min-width: 40%;
}
.name:hover {
background: #0b0b0b;
}
dt:target .name {
background: var(--highlight-color);
}
.name>span:first-child {
white-space: nowrap;
}
.name.class>span:nth-child(2) {
margin-left: .4em;
}
.inherited {
color: #999;
border-left: 5px solid #eee;
padding-left: 1em;
}
.inheritance em {
font-style: normal;
font-weight: bold;
}
.pydefname {
color: #f90;
}
/* Docstrings titles, e.g. in numpydoc format */
.desc h2 {
font-weight: 400;
font-size: 1.25em;
}
.desc h3 {
font-size: 1em;
}
.desc dt code {
background: inherit;
/* Don't grey-back parameters */
}
.source summary,
.git-link-div {
color: #666;
text-align: right;
font-weight: 400;
font-size: .8em;
text-transform: uppercase;
}
.source summary>* {
white-space: nowrap;
cursor: pointer;
}
.git-link {
color: inherit;
margin-left: 1em;
}
.source pre {
max-height: 500px;
overflow: auto;
margin: 0;
}
.source pre code {
font-size: 12px;
overflow: visible;
}
.hlist {
list-style: none;
}
.hlist li {
display: inline;
}
.hlist li:after {
content: ',\2002';
}
.hlist li:last-child:after {
content: none;
}
.hlist .hlist {
display: inline;
padding-left: 1em;
}
img {
max-width: 100%;
}
td {
padding: 0 .5em;
}
.admonition {
padding: .1em .5em;
margin-bottom: 1em;
}
.admonition-title {
font-weight: bold;
}
.admonition.note,
.admonition.info,
.admonition.important {
background: #00a;
}
.admonition.todo,
.admonition.versionadded,
.admonition.tip,
.admonition.hint {
background: #050;
}
.admonition.warning,
.admonition.versionchanged,
.admonition.deprecated {
background: #ec0;
}
.admonition.error,
.admonition.danger,
.admonition.caution {
background: #c20010;
}
p {
color: #fff;
}
</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os.path as osp
import numpy as np
import shutil
import sys
import tempfile
from argparse import Action, ArgumentParser
from collections import abc
from importlib import import_module
from addict import Dict


BASE_KEY = &#39;_base_&#39;
DELETE_KEY = &#39;_delete_&#39;


class ConfigDict(Dict):

    def __missing__(self, name):
        raise KeyError(name)

    def __getattr__(self, name):
        try:
            value = super(ConfigDict, self).__getattr__(name)
        except KeyError:
            ex = AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; object has no &#34;
                                f&#34;attribute &#39;{name}&#39;&#34;)
        except Exception as e:
            ex = e
        else:
            return value
        raise ex


def add_args(parser, cfg, prefix=&#39;&#39;):
    for k, v in cfg.items():
        if isinstance(v, str):
            parser.add_argument(&#39;--&#39; + prefix + k)
        elif isinstance(v, int):
            parser.add_argument(&#39;--&#39; + prefix + k, type=int)
        elif isinstance(v, float):
            parser.add_argument(&#39;--&#39; + prefix + k, type=float)
        elif isinstance(v, bool):
            parser.add_argument(&#39;--&#39; + prefix + k, action=&#39;store_true&#39;)
        elif isinstance(v, dict):
            add_args(parser, v, prefix + k + &#39;.&#39;)
        elif isinstance(v, abc.Iterable):
            parser.add_argument(&#39;--&#39; + prefix + k, type=type(v[0]), nargs=&#39;+&#39;)
        else:
            print(f&#39;cannot parse key {prefix + k} of type {type(v)}&#39;)
    return parser


class Config(object):
    &#34;&#34;&#34;A facility for config and config files.
    It supports common file formats as configs: python/json/yaml. The interface
    is the same as a dict object and also allows access config values as
    attributes.
    Example:
        &gt;&gt;&gt; cfg = Config(dict(a=1, b=dict(b1=[0, 1])))
        &gt;&gt;&gt; cfg.a
        1
        &gt;&gt;&gt; cfg.b
        {&#39;b1&#39;: [0, 1]}
        &gt;&gt;&gt; cfg.b.b1
        [0, 1]
        &gt;&gt;&gt; cfg = Config.fromfile(&#39;tests/data/config/a.py&#39;)
        &gt;&gt;&gt; cfg.filename
        &#34;/home/kchen/projects/mmcv/tests/data/config/a.py&#34;
        &gt;&gt;&gt; cfg.item4
        &#39;test&#39;
        &gt;&gt;&gt; cfg
        &#34;Config [path: /home/kchen/projects/mmcv/tests/data/config/a.py]: &#34;
        &#34;{&#39;item1&#39;: [1, 2], &#39;item2&#39;: {&#39;a&#39;: 0}, &#39;item3&#39;: True, &#39;item4&#39;: &#39;test&#39;}&#34;
    &#34;&#34;&#34;

    @staticmethod
    def _file2dict(filename):
        filename = osp.abspath(osp.expanduser(filename))
        if filename.endswith(&#39;.py&#39;):
            with tempfile.TemporaryDirectory() as temp_config_dir:
                temp_config_file = tempfile.NamedTemporaryFile(
                    dir=temp_config_dir, suffix=&#39;.py&#39;)
                temp_config_name = osp.basename(temp_config_file.name)
                # close temp file
                temp_config_file.close()
                shutil.copyfile(filename,
                                osp.join(temp_config_dir, temp_config_name))
                temp_module_name = osp.splitext(temp_config_name)[0]
                sys.path.insert(0, temp_config_dir)
                mod = import_module(temp_module_name)
                sys.path.pop(0)
                cfg_dict = {
                    name: value
                    for name, value in mod.__dict__.items()
                    if not name.startswith(&#39;__&#39;)
                }
                # delete imported module
                del sys.modules[temp_module_name]

        elif filename.endswith((&#39;.yml&#39;, &#39;.yaml&#39;, &#39;.json&#39;)):
            import mmcv
            cfg_dict = mmcv.load(filename)
        else:
            raise IOError(&#39;Only py/yml/yaml/json type are supported now!&#39;)

        cfg_text = filename + &#39;\n&#39;
        with open(filename, &#39;r&#39;) as f:
            cfg_text += f.read()

        if BASE_KEY in cfg_dict:
            cfg_dir = osp.dirname(filename)
            base_filename = cfg_dict.pop(BASE_KEY)
            base_filename = base_filename if isinstance(
                base_filename, list) else [base_filename]

            cfg_dict_list = list()
            cfg_text_list = list()
            for f in base_filename:
                _cfg_dict, _cfg_text = Config._file2dict(osp.join(cfg_dir, f))
                cfg_dict_list.append(_cfg_dict)
                cfg_text_list.append(_cfg_text)

            base_cfg_dict = dict()
            for c in cfg_dict_list:
                if len(base_cfg_dict.keys() &amp; c.keys()) &gt; 0:
                    raise KeyError(&#39;Duplicate key is not allowed among bases&#39;)
                base_cfg_dict.update(c)

            base_cfg_dict = Config._merge_a_into_b(cfg_dict, base_cfg_dict)
            cfg_dict = base_cfg_dict

            # merge cfg_text
            cfg_text_list.append(cfg_text)
            cfg_text = &#39;\n&#39;.join(cfg_text_list)

        return cfg_dict, cfg_text

    @staticmethod
    def _merge_a_into_b(a, b):
        # merge dict `a` into dict `b` (non-inplace). values in `a` will
        # overwrite `b`.
        # copy first to avoid inplace modification
        b = b.copy()
        for k, v in a.items():
            if isinstance(v, dict) and k in b and not v.pop(DELETE_KEY, False):
                if not isinstance(b[k], dict):
                    raise TypeError(
                        f&#39;{k}={v} in child config cannot inherit from base &#39;
                        f&#39;because {k} is a dict in the child config but is of &#39;
                        f&#39;type {type(b[k])} in base config. You may set &#39;
                        f&#39;`{DELETE_KEY}=True` to ignore the base config&#39;)
                b[k] = Config._merge_a_into_b(v, b[k])
            else:
                b[k] = v
        return b

    @staticmethod
    def fromfile(filename):
        cfg_dict, cfg_text = Config._file2dict(filename)
        return Config(cfg_dict, cfg_text=cfg_text, filename=filename)

    @staticmethod
    def auto_argparser(description=None):
        &#34;&#34;&#34;Generate argparser from config file automatically (experimental)
        &#34;&#34;&#34;
        partial_parser = ArgumentParser(description=description)
        partial_parser.add_argument(&#39;config&#39;, help=&#39;config file path&#39;)
        cfg_file = partial_parser.parse_known_args()[0].config
        cfg = Config.fromfile(cfg_file)
        parser = ArgumentParser(description=description)
        parser.add_argument(&#39;config&#39;, help=&#39;config file path&#39;)
        add_args(parser, cfg)
        return parser, cfg

    def __init__(self, cfg_dict=None, cfg_text=None, filename=None):
        if cfg_dict is None:
            cfg_dict = dict()
        elif not isinstance(cfg_dict, dict):
            raise TypeError(&#39;cfg_dict must be a dict, but &#39;
                            f&#39;got {type(cfg_dict)}&#39;)

        super(Config, self).__setattr__(&#39;_cfg_dict&#39;, ConfigDict(cfg_dict))
        super(Config, self).__setattr__(&#39;_filename&#39;, filename)
        if cfg_text:
            text = cfg_text
        elif filename:
            with open(filename, &#39;r&#39;) as f:
                text = f.read()
        else:
            text = &#39;&#39;
        super(Config, self).__setattr__(&#39;_text&#39;, text)

    @property
    def filename(self):
        return self._filename

    @property
    def text(self):
        return self._text

    @property
    def pretty_text(self):

        indent = 4

        def _indent(s_, num_spaces):
            s = s_.split(&#39;\n&#39;)
            if len(s) == 1:
                return s_
            first = s.pop(0)
            s = [(num_spaces * &#39; &#39;) + line for line in s]
            s = &#39;\n&#39;.join(s)
            s = first + &#39;\n&#39; + s
            return s

        def _format_basic_types(k, v):
            if isinstance(v, str):
                v_str = f&#34;&#39;{v}&#39;&#34;
            else:
                v_str = str(v)
            attr_str = f&#39;{str(k)}={v_str}&#39;
            attr_str = _indent(attr_str, indent)

            return attr_str

        def _format_list(k, v):
            # check if all items in the list are dict
            if all(isinstance(_, dict) for _ in v):
                v_str = &#39;[\n&#39;
                v_str += &#39;\n&#39;.join(
                    f&#39;dict({_indent(_format_dict(v_), indent)}),&#39;
                    for v_ in v).rstrip(&#39;,&#39;)
                attr_str = f&#39;{str(k)}={v_str}&#39;
                attr_str = _indent(attr_str, indent) + &#39;]&#39;
            else:
                attr_str = _format_basic_types(k, v)
            return attr_str

        def _format_dict(d, outest_level=False):
            r = &#39;&#39;
            s = []
            for idx, (k, v) in enumerate(d.items()):
                is_last = idx &gt;= len(d) - 1
                end = &#39;&#39; if outest_level or is_last else &#39;,&#39;
                if isinstance(v, dict):
                    v_str = &#39;\n&#39; + _format_dict(v)
                    attr_str = f&#39;{str(k)}=dict({v_str}&#39;
                    attr_str = _indent(attr_str, indent) + &#39;)&#39; + end
                elif isinstance(v, list):
                    attr_str = _format_list(k, v) + end
                else:
                    attr_str = _format_basic_types(k, v) + end

                s.append(attr_str)
            r += &#39;\n&#39;.join(s)
            return r

        cfg_dict = self._cfg_dict.to_dict()
        text = _format_dict(cfg_dict, outest_level=True)

        return text

    def __repr__(self):
        return f&#39;Config (path: {self.filename}): {self._cfg_dict.__repr__()}&#39;

    def __len__(self):
        return len(self._cfg_dict)

    def __getattr__(self, name):
        return getattr(self._cfg_dict, name)

    def __getitem__(self, name):
        return self._cfg_dict.__getitem__(name)

    def __setattr__(self, name, value):
        if isinstance(value, dict):
            value = ConfigDict(value)
        self._cfg_dict.__setattr__(name, value)

    def __setitem__(self, name, value):
        if isinstance(value, dict):
            value = ConfigDict(value)
        self._cfg_dict.__setitem__(name, value)

    def __iter__(self):
        return iter(self._cfg_dict)

    def dump(self):
        cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
        format_text = json.dumps(cfg_dict, indent=2)
        return format_text

    def merge_from_dict(self, options):
        &#34;&#34;&#34;Merge list into cfg_dict
        Merge the dict parsed by MultipleKVAction into this cfg.
        Examples:
            &gt;&gt;&gt; options = {&#39;model.backbone.depth&#39;: 50,
            ...            &#39;model.backbone.with_cp&#39;:True}
            &gt;&gt;&gt; cfg = Config(dict(model=dict(backbone=dict(type=&#39;ResNet&#39;))))
            &gt;&gt;&gt; cfg.merge_from_dict(options)
            &gt;&gt;&gt; cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
            &gt;&gt;&gt; assert cfg_dict == dict(
            ...     model=dict(backbone=dict(depth=50, with_cp=True)))
        Args:
            options (dict): dict of configs to merge from.
        &#34;&#34;&#34;
        option_cfg_dict = {}
        for full_key, v in options.items():
            d = option_cfg_dict
            key_list = full_key.split(&#39;.&#39;)
            for subkey in key_list[:-1]:
                d.setdefault(subkey, ConfigDict())
                d = d[subkey]
            subkey = key_list[-1]
            d[subkey] = v

        cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
        super(Config, self).__setattr__(
            &#39;_cfg_dict&#39;, Config._merge_a_into_b(option_cfg_dict, cfg_dict))


class DictAction(Action):
    &#34;&#34;&#34;
    argparse action to split an argument into KEY=VALUE form
    on the first = and append to a dictionary. List options should
    be passed as comma separated values, i.e KEY=V1,V2,V3
    &#34;&#34;&#34;

    @staticmethod
    def _parse_int_float_bool(val):
        try:
            return int(val)
        except ValueError:
            pass
        try:
            return float(val)
        except ValueError:
            pass
        if val.lower() in [&#39;true&#39;, &#39;false&#39;]:
            return True if val.lower() == &#39;true&#39; else False
        return val

    def __call__(self, parser, namespace, values, option_string=None):
        options = {}
        for kv in values:
            key, val = kv.split(&#39;=&#39;, maxsplit=1)
            val = [self._parse_int_float_bool(v) for v in val.split(&#39;,&#39;)]
            if len(val) == 1:
                val = val[0]
            options[key] = val
        setattr(namespace, self.dest, options)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.add_args"><code class="name flex">
<span>def <span class="ident">add_args</span></span>(<span>parser, cfg, prefix='')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_args(parser, cfg, prefix=&#39;&#39;):
    for k, v in cfg.items():
        if isinstance(v, str):
            parser.add_argument(&#39;--&#39; + prefix + k)
        elif isinstance(v, int):
            parser.add_argument(&#39;--&#39; + prefix + k, type=int)
        elif isinstance(v, float):
            parser.add_argument(&#39;--&#39; + prefix + k, type=float)
        elif isinstance(v, bool):
            parser.add_argument(&#39;--&#39; + prefix + k, action=&#39;store_true&#39;)
        elif isinstance(v, dict):
            add_args(parser, v, prefix + k + &#39;.&#39;)
        elif isinstance(v, abc.Iterable):
            parser.add_argument(&#39;--&#39; + prefix + k, type=type(v[0]), nargs=&#39;+&#39;)
        else:
            print(f&#39;cannot parse key {prefix + k} of type {type(v)}&#39;)
    return parser</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config"><code class="flex name class">
<span>class <span class="ident">Config</span></span>
<span>(</span><span>cfg_dict=None, cfg_text=None, filename=None)</span>
</code></dt>
<dd>
<div class="desc"><p>A facility for config and config files.
It supports common file formats as configs: python/json/yaml. The interface
is the same as a dict object and also allows access config values as
attributes.</p>
<h2 id="example">Example</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; cfg = Config(dict(a=1, b=dict(b1=[0, 1])))
&gt;&gt;&gt; cfg.a
1
&gt;&gt;&gt; cfg.b
{'b1': [0, 1]}
&gt;&gt;&gt; cfg.b.b1
[0, 1]
&gt;&gt;&gt; cfg = Config.fromfile('tests/data/config/a.py')
&gt;&gt;&gt; cfg.filename
&quot;/home/kchen/projects/mmcv/tests/data/config/a.py&quot;
&gt;&gt;&gt; cfg.item4
'test'
&gt;&gt;&gt; cfg
&quot;Config [path: /home/kchen/projects/mmcv/tests/data/config/a.py]: &quot;
&quot;{'item1': [1, 2], 'item2': {'a': 0}, 'item3': True, 'item4': 'test'}&quot;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Config(object):
    &#34;&#34;&#34;A facility for config and config files.
    It supports common file formats as configs: python/json/yaml. The interface
    is the same as a dict object and also allows access config values as
    attributes.
    Example:
        &gt;&gt;&gt; cfg = Config(dict(a=1, b=dict(b1=[0, 1])))
        &gt;&gt;&gt; cfg.a
        1
        &gt;&gt;&gt; cfg.b
        {&#39;b1&#39;: [0, 1]}
        &gt;&gt;&gt; cfg.b.b1
        [0, 1]
        &gt;&gt;&gt; cfg = Config.fromfile(&#39;tests/data/config/a.py&#39;)
        &gt;&gt;&gt; cfg.filename
        &#34;/home/kchen/projects/mmcv/tests/data/config/a.py&#34;
        &gt;&gt;&gt; cfg.item4
        &#39;test&#39;
        &gt;&gt;&gt; cfg
        &#34;Config [path: /home/kchen/projects/mmcv/tests/data/config/a.py]: &#34;
        &#34;{&#39;item1&#39;: [1, 2], &#39;item2&#39;: {&#39;a&#39;: 0}, &#39;item3&#39;: True, &#39;item4&#39;: &#39;test&#39;}&#34;
    &#34;&#34;&#34;

    @staticmethod
    def _file2dict(filename):
        filename = osp.abspath(osp.expanduser(filename))
        if filename.endswith(&#39;.py&#39;):
            with tempfile.TemporaryDirectory() as temp_config_dir:
                temp_config_file = tempfile.NamedTemporaryFile(
                    dir=temp_config_dir, suffix=&#39;.py&#39;)
                temp_config_name = osp.basename(temp_config_file.name)
                # close temp file
                temp_config_file.close()
                shutil.copyfile(filename,
                                osp.join(temp_config_dir, temp_config_name))
                temp_module_name = osp.splitext(temp_config_name)[0]
                sys.path.insert(0, temp_config_dir)
                mod = import_module(temp_module_name)
                sys.path.pop(0)
                cfg_dict = {
                    name: value
                    for name, value in mod.__dict__.items()
                    if not name.startswith(&#39;__&#39;)
                }
                # delete imported module
                del sys.modules[temp_module_name]

        elif filename.endswith((&#39;.yml&#39;, &#39;.yaml&#39;, &#39;.json&#39;)):
            import mmcv
            cfg_dict = mmcv.load(filename)
        else:
            raise IOError(&#39;Only py/yml/yaml/json type are supported now!&#39;)

        cfg_text = filename + &#39;\n&#39;
        with open(filename, &#39;r&#39;) as f:
            cfg_text += f.read()

        if BASE_KEY in cfg_dict:
            cfg_dir = osp.dirname(filename)
            base_filename = cfg_dict.pop(BASE_KEY)
            base_filename = base_filename if isinstance(
                base_filename, list) else [base_filename]

            cfg_dict_list = list()
            cfg_text_list = list()
            for f in base_filename:
                _cfg_dict, _cfg_text = Config._file2dict(osp.join(cfg_dir, f))
                cfg_dict_list.append(_cfg_dict)
                cfg_text_list.append(_cfg_text)

            base_cfg_dict = dict()
            for c in cfg_dict_list:
                if len(base_cfg_dict.keys() &amp; c.keys()) &gt; 0:
                    raise KeyError(&#39;Duplicate key is not allowed among bases&#39;)
                base_cfg_dict.update(c)

            base_cfg_dict = Config._merge_a_into_b(cfg_dict, base_cfg_dict)
            cfg_dict = base_cfg_dict

            # merge cfg_text
            cfg_text_list.append(cfg_text)
            cfg_text = &#39;\n&#39;.join(cfg_text_list)

        return cfg_dict, cfg_text

    @staticmethod
    def _merge_a_into_b(a, b):
        # merge dict `a` into dict `b` (non-inplace). values in `a` will
        # overwrite `b`.
        # copy first to avoid inplace modification
        b = b.copy()
        for k, v in a.items():
            if isinstance(v, dict) and k in b and not v.pop(DELETE_KEY, False):
                if not isinstance(b[k], dict):
                    raise TypeError(
                        f&#39;{k}={v} in child config cannot inherit from base &#39;
                        f&#39;because {k} is a dict in the child config but is of &#39;
                        f&#39;type {type(b[k])} in base config. You may set &#39;
                        f&#39;`{DELETE_KEY}=True` to ignore the base config&#39;)
                b[k] = Config._merge_a_into_b(v, b[k])
            else:
                b[k] = v
        return b

    @staticmethod
    def fromfile(filename):
        cfg_dict, cfg_text = Config._file2dict(filename)
        return Config(cfg_dict, cfg_text=cfg_text, filename=filename)

    @staticmethod
    def auto_argparser(description=None):
        &#34;&#34;&#34;Generate argparser from config file automatically (experimental)
        &#34;&#34;&#34;
        partial_parser = ArgumentParser(description=description)
        partial_parser.add_argument(&#39;config&#39;, help=&#39;config file path&#39;)
        cfg_file = partial_parser.parse_known_args()[0].config
        cfg = Config.fromfile(cfg_file)
        parser = ArgumentParser(description=description)
        parser.add_argument(&#39;config&#39;, help=&#39;config file path&#39;)
        add_args(parser, cfg)
        return parser, cfg

    def __init__(self, cfg_dict=None, cfg_text=None, filename=None):
        if cfg_dict is None:
            cfg_dict = dict()
        elif not isinstance(cfg_dict, dict):
            raise TypeError(&#39;cfg_dict must be a dict, but &#39;
                            f&#39;got {type(cfg_dict)}&#39;)

        super(Config, self).__setattr__(&#39;_cfg_dict&#39;, ConfigDict(cfg_dict))
        super(Config, self).__setattr__(&#39;_filename&#39;, filename)
        if cfg_text:
            text = cfg_text
        elif filename:
            with open(filename, &#39;r&#39;) as f:
                text = f.read()
        else:
            text = &#39;&#39;
        super(Config, self).__setattr__(&#39;_text&#39;, text)

    @property
    def filename(self):
        return self._filename

    @property
    def text(self):
        return self._text

    @property
    def pretty_text(self):

        indent = 4

        def _indent(s_, num_spaces):
            s = s_.split(&#39;\n&#39;)
            if len(s) == 1:
                return s_
            first = s.pop(0)
            s = [(num_spaces * &#39; &#39;) + line for line in s]
            s = &#39;\n&#39;.join(s)
            s = first + &#39;\n&#39; + s
            return s

        def _format_basic_types(k, v):
            if isinstance(v, str):
                v_str = f&#34;&#39;{v}&#39;&#34;
            else:
                v_str = str(v)
            attr_str = f&#39;{str(k)}={v_str}&#39;
            attr_str = _indent(attr_str, indent)

            return attr_str

        def _format_list(k, v):
            # check if all items in the list are dict
            if all(isinstance(_, dict) for _ in v):
                v_str = &#39;[\n&#39;
                v_str += &#39;\n&#39;.join(
                    f&#39;dict({_indent(_format_dict(v_), indent)}),&#39;
                    for v_ in v).rstrip(&#39;,&#39;)
                attr_str = f&#39;{str(k)}={v_str}&#39;
                attr_str = _indent(attr_str, indent) + &#39;]&#39;
            else:
                attr_str = _format_basic_types(k, v)
            return attr_str

        def _format_dict(d, outest_level=False):
            r = &#39;&#39;
            s = []
            for idx, (k, v) in enumerate(d.items()):
                is_last = idx &gt;= len(d) - 1
                end = &#39;&#39; if outest_level or is_last else &#39;,&#39;
                if isinstance(v, dict):
                    v_str = &#39;\n&#39; + _format_dict(v)
                    attr_str = f&#39;{str(k)}=dict({v_str}&#39;
                    attr_str = _indent(attr_str, indent) + &#39;)&#39; + end
                elif isinstance(v, list):
                    attr_str = _format_list(k, v) + end
                else:
                    attr_str = _format_basic_types(k, v) + end

                s.append(attr_str)
            r += &#39;\n&#39;.join(s)
            return r

        cfg_dict = self._cfg_dict.to_dict()
        text = _format_dict(cfg_dict, outest_level=True)

        return text

    def __repr__(self):
        return f&#39;Config (path: {self.filename}): {self._cfg_dict.__repr__()}&#39;

    def __len__(self):
        return len(self._cfg_dict)

    def __getattr__(self, name):
        return getattr(self._cfg_dict, name)

    def __getitem__(self, name):
        return self._cfg_dict.__getitem__(name)

    def __setattr__(self, name, value):
        if isinstance(value, dict):
            value = ConfigDict(value)
        self._cfg_dict.__setattr__(name, value)

    def __setitem__(self, name, value):
        if isinstance(value, dict):
            value = ConfigDict(value)
        self._cfg_dict.__setitem__(name, value)

    def __iter__(self):
        return iter(self._cfg_dict)

    def dump(self):
        cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
        format_text = json.dumps(cfg_dict, indent=2)
        return format_text

    def merge_from_dict(self, options):
        &#34;&#34;&#34;Merge list into cfg_dict
        Merge the dict parsed by MultipleKVAction into this cfg.
        Examples:
            &gt;&gt;&gt; options = {&#39;model.backbone.depth&#39;: 50,
            ...            &#39;model.backbone.with_cp&#39;:True}
            &gt;&gt;&gt; cfg = Config(dict(model=dict(backbone=dict(type=&#39;ResNet&#39;))))
            &gt;&gt;&gt; cfg.merge_from_dict(options)
            &gt;&gt;&gt; cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
            &gt;&gt;&gt; assert cfg_dict == dict(
            ...     model=dict(backbone=dict(depth=50, with_cp=True)))
        Args:
            options (dict): dict of configs to merge from.
        &#34;&#34;&#34;
        option_cfg_dict = {}
        for full_key, v in options.items():
            d = option_cfg_dict
            key_list = full_key.split(&#39;.&#39;)
            for subkey in key_list[:-1]:
                d.setdefault(subkey, ConfigDict())
                d = d[subkey]
            subkey = key_list[-1]
            d[subkey] = v

        cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
        super(Config, self).__setattr__(
            &#39;_cfg_dict&#39;, Config._merge_a_into_b(option_cfg_dict, cfg_dict))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.auto_argparser"><code class="name flex">
<span>def <span class="ident">auto_argparser</span></span>(<span>description=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate argparser from config file automatically (experimental)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def auto_argparser(description=None):
    &#34;&#34;&#34;Generate argparser from config file automatically (experimental)
    &#34;&#34;&#34;
    partial_parser = ArgumentParser(description=description)
    partial_parser.add_argument(&#39;config&#39;, help=&#39;config file path&#39;)
    cfg_file = partial_parser.parse_known_args()[0].config
    cfg = Config.fromfile(cfg_file)
    parser = ArgumentParser(description=description)
    parser.add_argument(&#39;config&#39;, help=&#39;config file path&#39;)
    add_args(parser, cfg)
    return parser, cfg</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.fromfile"><code class="name flex">
<span>def <span class="ident">fromfile</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fromfile(filename):
    cfg_dict, cfg_text = Config._file2dict(filename)
    return Config(cfg_dict, cfg_text=cfg_text, filename=filename)</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.filename"><code class="name">var <span class="ident">filename</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def filename(self):
    return self._filename</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.pretty_text"><code class="name">var <span class="ident">pretty_text</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pretty_text(self):

    indent = 4

    def _indent(s_, num_spaces):
        s = s_.split(&#39;\n&#39;)
        if len(s) == 1:
            return s_
        first = s.pop(0)
        s = [(num_spaces * &#39; &#39;) + line for line in s]
        s = &#39;\n&#39;.join(s)
        s = first + &#39;\n&#39; + s
        return s

    def _format_basic_types(k, v):
        if isinstance(v, str):
            v_str = f&#34;&#39;{v}&#39;&#34;
        else:
            v_str = str(v)
        attr_str = f&#39;{str(k)}={v_str}&#39;
        attr_str = _indent(attr_str, indent)

        return attr_str

    def _format_list(k, v):
        # check if all items in the list are dict
        if all(isinstance(_, dict) for _ in v):
            v_str = &#39;[\n&#39;
            v_str += &#39;\n&#39;.join(
                f&#39;dict({_indent(_format_dict(v_), indent)}),&#39;
                for v_ in v).rstrip(&#39;,&#39;)
            attr_str = f&#39;{str(k)}={v_str}&#39;
            attr_str = _indent(attr_str, indent) + &#39;]&#39;
        else:
            attr_str = _format_basic_types(k, v)
        return attr_str

    def _format_dict(d, outest_level=False):
        r = &#39;&#39;
        s = []
        for idx, (k, v) in enumerate(d.items()):
            is_last = idx &gt;= len(d) - 1
            end = &#39;&#39; if outest_level or is_last else &#39;,&#39;
            if isinstance(v, dict):
                v_str = &#39;\n&#39; + _format_dict(v)
                attr_str = f&#39;{str(k)}=dict({v_str}&#39;
                attr_str = _indent(attr_str, indent) + &#39;)&#39; + end
            elif isinstance(v, list):
                attr_str = _format_list(k, v) + end
            else:
                attr_str = _format_basic_types(k, v) + end

            s.append(attr_str)
        r += &#39;\n&#39;.join(s)
        return r

    cfg_dict = self._cfg_dict.to_dict()
    text = _format_dict(cfg_dict, outest_level=True)

    return text</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.text"><code class="name">var <span class="ident">text</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def text(self):
    return self._text</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dump(self):
    cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
    format_text = json.dumps(cfg_dict, indent=2)
    return format_text</code></pre>
</details>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.merge_from_dict"><code class="name flex">
<span>def <span class="ident">merge_from_dict</span></span>(<span>self, options)</span>
</code></dt>
<dd>
<div class="desc"><p>Merge list into cfg_dict
Merge the dict parsed by MultipleKVAction into this cfg.</p>
<h2 id="examples">Examples</h2>
<pre><code class="language-python-repl">&gt;&gt;&gt; options = {'model.backbone.depth': 50,
...            'model.backbone.with_cp':True}
&gt;&gt;&gt; cfg = Config(dict(model=dict(backbone=dict(type='ResNet'))))
&gt;&gt;&gt; cfg.merge_from_dict(options)
&gt;&gt;&gt; cfg_dict = super(Config, self).__getattribute__('_cfg_dict')
&gt;&gt;&gt; assert cfg_dict == dict(
...     model=dict(backbone=dict(depth=50, with_cp=True)))
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>options</code></strong> :&ensp;<code>dict</code></dt>
<dd>dict of configs to merge from.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def merge_from_dict(self, options):
    &#34;&#34;&#34;Merge list into cfg_dict
    Merge the dict parsed by MultipleKVAction into this cfg.
    Examples:
        &gt;&gt;&gt; options = {&#39;model.backbone.depth&#39;: 50,
        ...            &#39;model.backbone.with_cp&#39;:True}
        &gt;&gt;&gt; cfg = Config(dict(model=dict(backbone=dict(type=&#39;ResNet&#39;))))
        &gt;&gt;&gt; cfg.merge_from_dict(options)
        &gt;&gt;&gt; cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
        &gt;&gt;&gt; assert cfg_dict == dict(
        ...     model=dict(backbone=dict(depth=50, with_cp=True)))
    Args:
        options (dict): dict of configs to merge from.
    &#34;&#34;&#34;
    option_cfg_dict = {}
    for full_key, v in options.items():
        d = option_cfg_dict
        key_list = full_key.split(&#39;.&#39;)
        for subkey in key_list[:-1]:
            d.setdefault(subkey, ConfigDict())
            d = d[subkey]
        subkey = key_list[-1]
        d[subkey] = v

    cfg_dict = super(Config, self).__getattribute__(&#39;_cfg_dict&#39;)
    super(Config, self).__setattr__(
        &#39;_cfg_dict&#39;, Config._merge_a_into_b(option_cfg_dict, cfg_dict))</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.ConfigDict"><code class="flex name class">
<span>class <span class="ident">ConfigDict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>dict() -&gt; new empty dictionary
dict(mapping) -&gt; new dictionary initialized from a mapping object's
(key, value) pairs
dict(iterable) -&gt; new dictionary initialized as if via:
d = {}
for k, v in iterable:
d[k] = v
dict(**kwargs) -&gt; new dictionary initialized with the name=value pairs
in the keyword argument list.
For example:
dict(one=1, two=2)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigDict(Dict):

    def __missing__(self, name):
        raise KeyError(name)

    def __getattr__(self, name):
        try:
            value = super(ConfigDict, self).__getattr__(name)
        except KeyError:
            ex = AttributeError(f&#34;&#39;{self.__class__.__name__}&#39; object has no &#34;
                                f&#34;attribute &#39;{name}&#39;&#34;)
        except Exception as e:
            ex = e
        else:
            return value
        raise ex</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>addict.addict.Dict</li>
<li>builtins.dict</li>
</ul>
</dd>
<dt id="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.DictAction"><code class="flex name class">
<span>class <span class="ident">DictAction</span></span>
<span>(</span><span>option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)</span>
</code></dt>
<dd>
<div class="desc"><p>argparse action to split an argument into KEY=VALUE form
on the first = and append to a dictionary. List options should
be passed as comma separated values, i.e KEY=V1,V2,V3</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DictAction(Action):
    &#34;&#34;&#34;
    argparse action to split an argument into KEY=VALUE form
    on the first = and append to a dictionary. List options should
    be passed as comma separated values, i.e KEY=V1,V2,V3
    &#34;&#34;&#34;

    @staticmethod
    def _parse_int_float_bool(val):
        try:
            return int(val)
        except ValueError:
            pass
        try:
            return float(val)
        except ValueError:
            pass
        if val.lower() in [&#39;true&#39;, &#39;false&#39;]:
            return True if val.lower() == &#39;true&#39; else False
        return val

    def __call__(self, parser, namespace, values, option_string=None):
        options = {}
        for kv in values:
            key, val = kv.split(&#39;=&#39;, maxsplit=1)
            val = [self._parse_int_float_bool(v) for v in val.split(&#39;,&#39;)]
            if len(val) == 1:
                val = val[0]
            options[key] = val
        setattr(namespace, self.dest, options)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>argparse.Action</li>
<li>argparse._AttributeHolder</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs" href="index.html">Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.add_args" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.add_args">add_args</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config">Config</a></code></h4>
<ul class="two-column">
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.auto_argparser" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.auto_argparser">auto_argparser</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.dump" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.dump">dump</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.filename" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.filename">filename</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.fromfile" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.fromfile">fromfile</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.merge_from_dict" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.merge_from_dict">merge_from_dict</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.pretty_text" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.pretty_text">pretty_text</a></code></li>
<li><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.text" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.Config.text">text</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.ConfigDict" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.ConfigDict">ConfigDict</a></code></h4>
</li>
<li>
<h4><code><a title="Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.DictAction" href="#Euro-Truck-Simulator-2-Lane-Assist.plugins.UFLDLaneDetection.UFLD.ultrafastLaneDetector.exportLib.ultrafastLaneV2.configs.config.DictAction">DictAction</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>